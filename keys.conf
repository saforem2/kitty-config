# vim:ft=kitty:fdm=marker
#
map kitty_mod+f launch --type=window --allow-remote-control ~/.config/kitty/kitty-tab-switcher/kitty-tab-switcher

macos_option_as_alt yes
# macos_quit_when_last_window_closed yes
map cmd+shift+d launch --location=hsplit
map cmd+d launch --location=vsplit
map kitty_mod+d launch --location=hsplit

map shift+up move_window up
map shift+left move_window left
map shift+right move_window right
map shift+down move_window down

# Rotate the current split, chaging its split axis from vertical to
# horizontal or vice versa
# map kitty_mod+enter layout_action rotate
map F7 layout_action rotate

# Move the active window in the indicated direction
map kitty_mod+up move_window up
map kitty_mod+left move_window left
map kitty_mod+right move_window right
map kitty_mod+down move_window down

# map alt+left neighboring_window left
# map alt+right neighboring_window right
# map alt+up neighboring_window up
# map alt+down neighboring_window down
# #
# Euporie custom keybinds
# map ctrl+enter send_text normal,application \x1b[13;5u
# map shift+enter send_text normal,application \x1b[13;2u


map kitty_mod+enter no_op
# map ctrl+alt+enter next_layout
# map alt+enter next_layout
map alt+enter kitten zoom_toggle.py
# map cmd+enter kitten zoom_toggle.py
# map cmd+shift+enter kitten zoom_toggle.py
# map ctrl+enter kitten zoom_toggle.py
# map shift+enter kitten zoom_toggle.py

# map cmd+alt+h neighboring_window left
# map cmd+alt+l neighboring_window right
# map cmd+alt+k neighboring_window up
# map cmd+alt+j neighboring_window down

map ctrl+cmd+left resize_window narrower
map ctrl+cmd+right resize_window wider
map ctrl+cmd+up resize_window taller
map ctrl+cmd+down resize_window shorter 3

# map ctrl+j kitten pass_keys.py neighboring_window bottom ctrl+j
# map ctrl+k kitten pass_keys.py neighboring_window top    ctrl+k
# map ctrl+h kitten pass_keys.py neighboring_window left   ctrl+h
# map ctrl+l kitten pass_keys.py neighboring_window right  ctrl+l

# Create a new window splitting the space used by the existing one so that
# the two windows are placed one above the other
# map F5 launch --location=hsplit

# Create a new window splitting the space used by the existing one so that
# the two windows are placed side by side
# map F6 launch --location=vsplit

# Create a new window splitting the space used by the existing one so that
# the two windows are placed side by side if the existing window is wide or
# one above the other if the existing window is tall.
# map F4 launch --location=split

# Rotate the current split, chaging its split axis from vertical to
# horizontal or vice versa
# map kity_mod+enter layout_action rotate
# map F7 layout_action rotate

# Move the active window in the indicated direction
# map kitty_mod+up move_window up
# map kitty_mod+left move_window left
# map kitty_mod+right move_window right
# map kitty_mod+down move_window down

# Switch focus to the neighboring window in the indicated direction
# map ctrl+left neighboring_window left
# map ctrl+right neighboring_window right
# map ctrl+up neighboring_window up
# map ctrl+down neighboring_window down

# map alt+
# map alt+left neighboring_window left
# map alt+right neighboring_window right
# map alt+up neighboring_window up
# map alt+down neighboring_window down

map alt+h neighboring_window left
map alt+l neighboring_window right
map alt+k neighboring_window up
map alt+j neighboring_window down

# map alt+k kitten pass_keys.py neighboring_window top    ctrl+k
# map atl+j kitten pass_keys.py neighboring_window bottom ctrl+j
# map alt+h kitten pass_keys.py neighboring_window left   ctrl+h
# map alt+l kitten pass_keys.py neighboring_window right  ctrl+l


# map alt+left neighboring_window left
# map alt+right neighboring_window right
# map alt+up neighboring_window up
# map alt+down neighboring_window down
# #
# Euporie custom keybinds
# map ctrl+enter send_text normal,application \x1b[13;5u
# map shift+enter send_text normal,application \x1b[13;2u

# vim-kitty-navigator keybinds
# map ctrl+j kitten pass_keys.py neighboring_window bottom ctrl+j
# map ctrl+k kitten pass_keys.py neighboring_window top    ctrl+k
# map ctrl+h kitten pass_keys.py neighboring_window left   ctrl+h
# map ctrl+l kitten pass_keys.py neighboring_window Right  ctrl+l
# map alt+l no_op
# map alt+h no_op
# map ctrl+k no_op
# map ctrl+j no_op

# map alt+j kitten pass_keys.py neighboring_window bottom alt+j "^.* - nvim$"
# map alt+k kitten pass_keys.py neighboring_window top    alt+k "^.* - nvim$"
# map alt+h kitten pass_keys.py neighboring_window left   alt+h "^.* - nvim$"
# map alt+l kitten pass_keys.py neighboring_window right  alt+l "^.* - nvim$"

# map cmd+j kitten pass_keys.py neighboring_window bottom cmd+j "^.* - nvim$"
# map cmd+k kitten pass_keys.py neighboring_window top    cmd+k "^.* - nvim$"
# map cmd+h kitten pass_keys.py neighboring_window left   cmd+h "^.* - nvim$"
# map cmd+l kitten pass_keys.py neighboring_window right  cmd+l "^.* - nvim$"

# map ctrl+j kitten pass_keys.py neighboring_window bottom ctrl+j
# map ctrl+k kitten pass_keys.py neighboring_window top    ctrl+k
# map ctrl+h kitten pass_keys.py neighboring_window left   ctrl+h
# map ctrl+l kitten pass_keys.py neighboring_window Right  ctrl+l

# map ctrl+shift+v kitten kitty_grab/grab.py
# map kitty_mod+f kitten kitty_grab/grab.py
#: }}}

# Create a new window splitting the space used by the existing one so that
# the two windows are placed one above the other
# map F5 launch --location=hsplit

# Create a new window splitting the space used by the existing one so that
# the two windows are placed side by side
# map F6 launch --location=vsplit

# Create a new window splitting the space used by the existing one so that
# the two windows are placed side by side if the existing window is wide or
# one above the other if the existing window is tall.
# map F4 launch --location=split

# vim-kitty-navigator keybinds
# map ctrl+j kitten pass_keys.py neighboring_window bottom ctrl+j
# map ctrl+k kitten pass_keys.py neighboring_window top    ctrl+k
# map ctrl+h kitten pass_keys.py neighboring_window left   ctrl+h
# map ctrl+l kitten pass_keys.py neighboring_window Right  ctrl+l
# map alt+l no_op
# map alt+h no_op
# map ctrl+k no_op
# map ctrl+j no_op

# map alt+j kitten pass_keys.py neighboring_window bottom alt+j "^.* - nvim$"
# map alt+k kitten pass_keys.py neighboring_window top    alt+k "^.* - nvim$"
# map alt+h kitten pass_keys.py neighboring_window left   alt+h "^.* - nvim$"
# map alt+l kitten pass_keys.py neighboring_window right  alt+l "^.* - nvim$"

# map cmd+j kitten pass_keys.py neighboring_window bottom cmd+j "^.* - nvim$"
# map cmd+k kitten pass_keys.py neighboring_window top    cmd+k "^.* - nvim$"
# map cmd+h kitten pass_keys.py neighboring_window left   cmd+h "^.* - nvim$"
# map cmd+l kitten pass_keys.py neighboring_window right  cmd+l "^.* - nvim$"

# map ctrl+j kitten pass_keys.py neighboring_window bottom ctrl+j
# map ctrl+k kitten pass_keys.py neighboring_window top    ctrl+k
# map ctrl+h kitten pass_keys.py neighboring_window left   ctrl+h
# map ctrl+l kitten pass_keys.py neighboring_window Right  ctrl+l
#



# map opt+j kitten pass_keys.py neighboring_window bottom ctrl+j
# map opt+k kitten pass_keys.py neighboring_window top    ctrl+k
# map opt+h kitten pass_keys.py neighboring_window left   ctrl+h
# map opt+l kitten pass_keys.py neighboring_window Right  ctrl+l
#
#
# # Switch focus to the neighboring window in the indicated direction
# map ctrl+left neighboring_window left
# map ctrl+right neighboring_window right
# map ctrl+up neighboring_window up
# map ctrl+down neighboring_window down
#
# map opt+left neighboring_window left
# map opt+right neighboring_window right
# map opt+up neighboring_window up
# map opt+down neighboring_window down




# -----------------------------------------------------------------------------------------------------
# map opt+j kitten pass_keys.py neighboring_window bottom ctrl+j
# map opt+k kitten pass_keys.py neighboring_window top    ctrl+k
# map opt+h kitten pass_keys.py neighboring_window left   ctrl+h
# map opt+l kitten pass_keys.py neighboring_window Right  ctrl+l

# map ctrl+j kitten pass_keys.py neighboring_window bottom ctrl+j
# map ctrl+k kitten pass_keys.py neighboring_window top    ctrl+k
# map ctrl+h kitten pass_keys.py neighboring_window left   ctrl+h
# map ctrl+l kitten pass_keys.py neighboring_window Right  ctrl+l


# map alt+k kitten pass_keys.py neighboring_window top    alt+k "^.* - nvim$"
# map alt+j kitten pass_keys.py neighboring_window bottom alt+j "^.* - nvim$"
# map alt+h kitten pass_keys.py neighboring_window left   alt+h "^.* - nvim$"
# map alt+l kitten pass_keys.py neighboring_window right  alt+l "^.* - nvim$"

# map cmd+shift+j kitten pass_keys.py neighboring_window bottom cmd+shift+j "^.* - nvim$"
# map cmd+shift+k kitten pass_keys.py neighboring_window top    cmd+shift+k "^.* - nvim$"
# map cmd+shift+h kitten pass_keys.py neighboring_window left   cmd+shift+h "^.* - nvim$"
# map cmd+shift+l kitten pass_keys.py neighboring_window right  cmd+shift+l "^.* - nvim$"

#: Keyboard shortcuts {{{

map kitty_mod+a kitten kitty_grab/grab.py
# map c

map super+f pipe @ansi overlay /Users/samforeman/.local/bin/vim-ansi
map super+e kitten hints
# copy url
map super+shift+e khints --program @
# copy selected path
map super+shift+c khints --type path --program @
# file path
map super+p khints --type path --program -
map super+shift+p khints --multiple --type path --program -
# any line
map super+i khints --type line --program -
map super+shift+i khints --multiple --type line --program -
# copy line
map super+y khints --type line --program @
# copy multiple line
map super+shift+y khints --multiple --type line --program @


#: Keys are identified simply by their lowercase unicode characters.
#: For example: ``a`` for the A key, ``[`` for the left square bracket
#: key, etc. For functional keys, such as ``Enter or Escape`` the
#: names are present at https://sw.kovidgoyal.net/kitty/keyboard-
#: protocol/#functional-key-definitions. For modifier keys, the names
#: are ctrl (control, ⌃), shift (⇧), alt (opt, option, ⌥), super (cmd,
#: command, ⌘). See also: GLFW mods
#: <https://www.glfw.org/docs/latest/group__mods.html>

#: On Linux you can also use XKB key names to bind keys that are not
#: supported by GLFW. See XKB keys
#: <https://github.com/xkbcommon/libxkbcommon/blob/master/include/xkbcommon/xkbcommon-
#: keysyms.h> for a list of key names. The name to use is the part
#: after the XKB_KEY_ prefix. Note that you can only use an XKB key
#: name for keys that are not known as GLFW keys.

#: Finally, you can use raw system key codes to map keys, again only
#: for keys that are not known as GLFW keys. To see the system key
#: code for a key, start kitty with the kitty --debug-input option.
#: Then kitty will output some debug text for every key event. In that
#: text look for ``native_code`` the value of that becomes the key
#: name in the shortcut. For example:

#: .. code-block:: none

#:     on_key_input: glfw key: 65 native_code: 0x61 action: PRESS mods: 0x0 text: 'a'

#: Here, the key name for the A key is 0x61 and you can use it with::

#:     map ctrl+0x61 something

#: to map ctrl+a to something.

# map cmd+h no_op

#: You can use the special action no_op to unmap a keyboard shortcut
#: that is assigned in the default configuration::

#:     map kitty_mod+space no_op

#: If you would like kitty to completely ignore a key event, not even
#: sending it to the program running in the terminal, map it to
#: discard_event::

#:     map kitty_mod+f1 discard_event

#: You can combine multiple actions to be triggered by a single
#: shortcut, using the syntax below::

#:     map key combine <separator> action1 <separator> action2 <separator> action3 ...

#: For example::

#:     map kitty_mod+e combine : new_window : next_layout

#: this will create a new window and switch to the next available
#: layout

#: You can use multi-key shortcuts using the syntax shown below::

#:     map key1>key2>key3 action

#: For example::

#:     map ctrl+f>2 set_font_size 20

#: The full list of actions that can be mapped to key presses is
#: available here </actions>.

# kitty_mod alt+shift
# kitty_mod ctrl+shift

# +------------------------+
# | KITTY MOD DEFINED HERE |
# +------------------------+
kitty_mod alt+shift

#: The value of kitty_mod is used as the modifier for all default
#: shortcuts, you can change it in your kitty.conf to change the
#: modifiers for all the default shortcuts.

clear_all_shortcuts no

#: You can have kitty remove all shortcut definition seen up to this
#: point. Useful, for instance, to remove the default shortcuts.

# action_alias

action_alias finder_view launch --type=overlay open -a Finder ${FILE_PATH}

#: E.g. action_alias launch_tab launch --type=tab --cwd=current

#: Define aliases to avoid repeating the same options in multiple
#: mappings. Aliases can be defined for any action. Aliases are
#: expanded recursively. For example, the above alias allows you to
#: create mappings to launch a new tab in the current working
#: directory without duplication::

#:     map f1 launch_tab vim
#:     map f2 launch_tab emacs

#: Similarly, to alias kitten invocation::

#:     action_alias hints khints --hints-offset=0
action_alias khints kitten hints --hints-offset=0 --alphabet=asdfqwert --hints-foreground-color=#FF1A8F --hints-background-color=#FFE0FF
# action_alias hints kitten hints --hints-offset=0 --alphabet=asdfqwert --hints-foreground-color=#FF1A8F --hints-background-color=#FFE0FF
# map kitty_mod+i kitten hints --alphabet=asdfqwert --hints-foreground-color=#FF1A8F --hints-background-color=#FFE0FF --type word --program -

# kitten_alias hints hints --hints-offset=0
# kitten_alias hints hints --alphabet=asdfqwert --hints-foreground-color=#FF1A8F --hints-background-color=#FFE0FF

#: E.g. kitten_alias hints hints --hints-offset=0

#: Like action_alias above but, specifically for kittens. Generally,
#: prefer to use action_alias. This option is a legacy version,
#: present for backwards compatibility. It causes all invocations of
#: the aliased kitten to be substituted. So the example above will
#: cause all invocations of the hints kitten to have the --hints-
#: offset=0 option applied.

#: Clipboard {{{

#: Copy to clipboard

map cmd+c copy_to_clipboard
# map kitty_mod+c copy_to_clipboard

#::  There is also a copy_or_interrupt action that can be optionally
#::  mapped to Ctrl+c. It will copy only if there is a selection and
#::  send an interrupt otherwise. Similarly,
#::  copy_and_clear_or_interrupt will copy and clear the selection or
#::  send an interrupt if there is no selection.

#: Paste from clipboard

# map kitty_mod+v paste_from_clipboard
map cmd+v paste_from_clipboard

#: Paste from selection

# map kitty_mod+s  paste_from_selection
# map shift+insert paste_from_selection
# map shift+cmd+v paste_from_selection
# map cmd+alt+v  paste_from_selection

#: Pass selection to program

# map kitty_mod+o pass_selection_to_program

#::  You can also pass the contents of the current selection to any
#::  program using pass_selection_to_program. By default, the system's
#::  open program is used, but you can specify your own, the selection
#::  will be passed as a command line argument to the program, for
#::  example::


map kitty_mod+o pass_selection_to_program $BROWSER
# map kitty_mod+y new_window less @selection

# map cmd+y copy_to_buffer y
# map opt+y paste_from_buffer y

#: }}}

#: Scrolling {{{

#: Scroll line up

# map kitty_mod+up    scroll_line_up
# map kitty_mod+k     scroll_line_up
# map opt+cmd+page_up scroll_line_up
# map cmd+up          scroll_line_up
map alt+up scroll_line_up
map alt+down scroll_line_down

#: Scroll line down

# map alt+j scroll_line_down
# map alt+k scroll_line_up
# map alt+h scroll_line_down
# map alt+l scroll_line_down
# map kitty_mod+down    scroll_line_down
# map kitty_mod+j       scroll_line_down
# map opt+cmd+page_down scroll_line_down
# map cmd+down          scroll_line_down

#: Scroll page up

# map kitty_mod+page_up scroll_page_up
map cmd+k scroll_page_up
map cmd+k scroll_page_up
map cmd+j scroll_page_down
map cmd+shift+up     scroll_page_up
map cmd+page_up       scroll_page_up
# map ctrl+shift+b      scroll_page_up


#: Scroll page down

# map kitty_mod+page_down scroll_page_down
map cmd+up+page_down       scroll_page_down
map cmd+shift+down     scroll_page_down
# map ctrl+shift+f      scroll_page_down

#: Scroll to top

# map kitty_mod+home scroll_home
# map cmd+home       scroll_home

#: Scroll to bottom

# map kitty_mod+end scroll_end
# map cmd+end       scroll_end

#: Scroll to previous shell prompt

# map kitty_mod+p scroll_to_prompt -1
# map kitty_mod+ scroll_to_prompt -1
# map kitty_mod+k scroll_to_prompt -1
map ctrl+b scroll_to_prompt -1
map ctrl+f scroll_to_prompt 1

map cmd+up scroll_to_prompt -1
map cmd+down scroll_to_prompt 1

map ctrl+k scroll_to_prompt -1
map ctrl+j scroll_to_prompt 1
#::  Use a parameter of zero for scroll_to_prompt to scroll to the
#::  last jumped to or the last clicked position. Requires
#::  https://sw.kovidgoyal.net/kitty/shell-integration/ to work.

#: Scroll to next shell prompt


#: Browse scrollback buffer in pager

# map alt+shift+esc show_scrollback
map kitty_mod+b show_scrollback
map alt+esc launch --stdin-source=@screen_scrollback --stdin-add-formatting --type=overlay less +G -R
# map kitty_mod+h show_scrollback

#::  You can pipe the contents of the current screen + history buffer
#::  as STDIN to an arbitrary program using the ``launch`` function.
#::  For example, the following opens the scrollback buffer in less in
#::  an overlay window::

#::      map f1 launch --stdin-source=@screen_scrollback --stdin-add-formatting --type=overlay less +G -R
# map kitty_mod+l launch --stdin-source=@screen_scrollback --stdin-add-formatting less +G -R
map kitty_mod+l launch --stdin-source=@screen_scrollback --stdin-add-formatting less +G -R

#::  For more details on piping screen and buffer contents to external
#::  programs, see launch.

#: Browse output of the last shell command in pager

map kitty_mod+g show_last_command_output

#::  You can also define additional shortcuts to get the command
#::  output. For example, to get the first command output on screen::

#::      map f1 show_first_command_output_on_screen

#::  To get the command output that was last accessed by a keyboard
#::  action or mouse action::

#::      map f1 show_last_visited_command_output

#::  You can pipe the output of the last command run in the shell
#::  using the launch function. For example, the following opens the
#::  output in less in an overlay window::

#::      map f1 launch --stdin-source=@last_cmd_output --stdin-add-formatting --type=overlay less +G -R
map kitty_mod+[ launch --stdin-source=@last_cmd_output --stdin-add-formatting --type=overlay less +G -R

#::  To get the output of the first command on the screen, use
#::  @first_cmd_output_on_screen. To get the output of the last jumped
#::  to command, use @last_visited_cmd_output.

#::  Requires https://sw.kovidgoyal.net/kitty/shell-integration/ to
#::  work.

#: }}}

#: Window management {{{

#: New window


#::  You can open a new window running an arbitrary program, for
#::  example::

#::      map kitty_mod+y      launch mutt

#::  You can open a new window with the current working directory set
#::  to the working directory of the current window using::

#::      map ctrl+alt+enter    launch --cwd=current

#::  You can open a new window that is allowed to control kitty via
#::  the kitty remote control facility by prefixing the command line
#::  with @. Any programs running in that window will be allowed to
#::  control kitty. For example::

#::      map ctrl+enter launch --allow-remote-control some_program

#::  You can open a new window next to the currently active window or
#::  as the first window, with::

#::      map ctrl+n launch --location=neighbor some_program
#::      map ctrl+f launch --location=first some_program

#::  For more details, see launch.

#: New OS window

# map kitty_mod+n new_os_window
map cmd+n       new_os_window

#::  Works like new_window above, except that it opens a top level OS
#::  kitty window. In particular you can use new_os_window_with_cwd to
#::  open a window with the current working directory.

#: Close window

map kitty_mod+w no_op
# map shift+cmd+d close_window

#: Next window

# map kitty_mod+] next_window

#: Previous window

# map kitty_mod+[ previous_window

#: Move window forward

# map kitty_mod+f move_window_forward

#: Move window backward

# map kitty_mod+b move_window_backward

#: Move window to top

# map kitty_mod+` move_window_to_top

#: Start resizing window

map kitty_mod+r no_op
# map cmd+r       start_resizing_window

#: Just as with new_window above, you can also pass the name of
#: arbitrary commands to run when using new_tab and use
#: new_tab_with_cwd. Finally, if you want the new tab to open next to
#: the current tab rather than at the end of the tabs list, use::

#:     map ctrl+t new_tab !neighbor [optional cmd to run]
#: }}}

#: Layout management {{{

#: Next layout

# map kitty_mod+l next_layout


#: You can also create shortcuts to switch to specific layouts::

#:     map ctrl+alt+t goto_layout tall
#:     map ctrl+alt+s goto_layout stack

#: Similarly, to switch back to the previous layout::

#:    map ctrl+alt+p last_used_layout

#: There is also a toggle layout function that switches to the named
#: layout or back to the previous layout if in the named layout.
#: Useful to temporarily "zoom" the active window by switching to the
#: stack layout::

#:     map ctrl+alt+z toggle_layout stack
#: }}}

#: Font sizes {{{

#: You can change the font size for all top-level kitty OS windows at
#: a time or only the current one.

#: Increase font size

# map alt+equal  change_font_size current +2.0
# map alt+plus   change_font_size current +2.0
# map kitty_mod+kp_add change_font_size current +2.0
# map cmd+plus         change_font_size all +2.0
# map cmd+equal        change_font_size all +2.0
# map alt+equal  change_font_size all +2.0

#: Decrease font size

# map kitty_mod+minus       change_font_size all -2.0
# map kitty_mod+kp_subtract change_font_size all -2.0
# map alt+minus             change_font_size current -1.0
# map shift+cmd+minus       change_font_size all -2.0

map kitty_mod+5 fifth_window
map kitty_mod+6 sixth_window
map kitty_mod+7 seventh_window
map kitty_mod+8 eighth_window
map kitty_mod+9 ninth_window
map kitty_mod+0 tenth_window
#: Visually select focus window
map ctrl+alt+space focus_visible_window
#: Visually swap window with another
# map f8 swap_with_window
map kitty_mod+f8 swap_with_window
map kitty_mod+8 swap_with_window
map kitty_mod+enter swap_with_window

#: }}}

#: Tab management {{{

#: Next tab

# map kitty_mod+right next_tab
map shift+cmd+]     next_tab
map ctrl+tab        next_tab

#: Previous tab

# map kitty_mod+left previous_tab
map shift+cmd+[    previous_tab
map ctrl+shift+tab previous_tab

#: New tab

# map kitty_mod+t new_tab
map cmd+t       new_tab

#: Close tab

# map kitty_mod+q close_tab
map cmd+w       close_tab

#: Close OS window

map shift+cmd+w close_os_window

#: Move tab forward

map ctrl+cmd+] move_tab_forward

#: Move tab backward

map ctrl+cmd+[ move_tab_backward
# map cmd+shift+, move_tab_backward
# map cmd+shift+. move_tab_forward

#: Set tab title

map kitty_mod+t set_tab_title
# map shift+cmd+i     set_tab_title


#: You can also create shortcuts to go to specific tabs, with 1 being
#: the first tab, 2 the second tab and -1 being the previously active
#: tab, and any number larger than the last tab being the last tab::

#:     map ctrl+alt+1 goto_tab 1
#:     map ctrl+alt+2 goto_tab 2
map cmd+1 goto_tab 1
map cmd+2 goto_tab 2
map cmd+3 goto_tab 3
map cmd+4 goto_tab 4
map cmd+5 goto_tab 5
map cmd+6 goto_tab 6
map cmd+7 goto_tab 7
map cmd+8 goto_tab 8
map cmd+9 goto_tab -1


# map cmd+;   launch zsh -c 'nvim'
# map cmd+.                       launch --type=overlay --cwd=${HOME}/.dotfiles zsh -c 'nvim'

#: Reset font size

# map kitty_mod+backspace change_font_size all 0
map cmd+0               change_font_size current 0
map ctrl+cmd+shift+=         change_font_size current +1.0
map ctrl+cmd+shift+-         change_font_size current -1.0


#: To setup shortcuts for specific font sizes::

#:     map kitty_mod+f6 change_font_size all 10.0

#: To setup shortcuts to change only the current OS window's font
#: size::

#:     map kitty_mod+f6 change_font_size current 10.0
#: }}}

# Set kitty as the handler for ssh:// URLs
# kitty +runpy 'from kitty.fast_data_types import cocoa_set_url_handler; import sys; cocoa_set_url_handler(*sys.argv[1:]); print("OK")' ssh
# Set someapp as the handler for xyz:// URLs
# kitty +runpy 'from kitty.fast_data_types import cocoa_set_url_handler; import sys; cocoa_set_url_handler(*sys.argv[1:]); print("OK")' xyz someapp.bundle.identifier

#: Select and act on visible text {{{

#: Use the hints kitten to select text and either pass it to an
#: external program or insert it into the terminal or copy it to the
#: clipboard.

#: Open URL

# map kitty_mod+e open_url_with_hints
map kitty_mod+e khints --type url
map kitty_mod+i khints --type word --program -
# map cmd+shift+e open_url_with_hints

#::  Open a currently visible URL using the keyboard. The program used
#::  to open the URL is specified in open_url_with.

# open_url_modifiers kitty_mod
# open_url_modifiers cmd+shift

#: The modifier keys to press when clicking with the mouse on URLs to
#: open the URL
#: Insert selected path

# map kitty_mod+f khints --type path --program -
# map cmd+shift+y kitten hints --type path --program -
# map kitty_mod+p>f kitten hints --type path --program -
# map cmd+shift+p>f kitten hints --type path --program -
map kitty_mod+p>f khints launch --type=overlay open -a Finder ${FILE_PATH}
# map kitty_mod+p>i kitten hints --type word --multiple --program -

#::  Select a path/filename and insert it into the terminal. Useful,
#::  for instance to run git commands on a filename output from a
#::  previous git command.

#: Open selected path

# #FFCCFF #FF1A8F
# #CCFFCC #1AA912
# #e4f2e3 #1da912
# #CCEEFF #118DC3
# #e3eff4 #118dc3
# #eaf3f4 #56b6c2
# #CCFFFF #56B6C2
# #DDFFFF #56B6C2
# #FFCCCC #D11A2A
# #fbe3e4 #d11a2a
# #f0edf6 #9a77cf
# #EEDDEE #9A77CF
# #FFE4CC #fd971f
# #ffe7cb #fd971f
#
# map kitty_mod+p>o kitten hints --type path --program Finder
# #FFE0FF #FF1A8F
# #FFE3E4 #D11A2A
# #E3EFF4 #118DC3
# #E4F2E3 #1DA912
# #F0EDF6 #9A77CF
# #EAF3F4 #56B6C2
# #FFE7CB #fd971f
# #FFE0FF #FF1A8F
# #FFF8DC #FD971F
# #EDEDED #CFCFCF
map kitty_mod+i khints --type word --program -
map kitty_mod+p>i khints --type word --multiple --program -
# copy line to clipboard with kitty_mod+y
map kitty_mod+y khints --type word --program @
map ctrl+y khints --type word --program @
map kitty_mod+p>o khints --type word --program -
map kitty_mod+p>y khints --type word --program o
map kitty_mod+p>shift+y khints --type line --program @
#::  You can pass the current selection to a terminal program running
#::  in a new kitty window, by using the @selection placeholder::

map kitty_mod+p>f khints --type path --program default
map kitty_mod+p>shift+f khints --type path --program default
map ctrl+cmd+p>shift+f khints --type path --program default


#::  Select a path/filename and open it with the default open program.

#: Insert selected line

map kitty_mod+p>l khints --type line --program -

#::  Select a line of text and insert it into the terminal. Use for
#::  the output of things like: ls -1

#: Insert selected word

map kitty_mod+p>w khints --type word --program -

#::  Select words and insert into terminal.

#: Insert selected hash

map kitty_mod+p>h khints --type hash --program -

#::  Select something that looks like a hash and insert it into the
#::  terminal. Useful with git, which uses sha1 hashes to identify
#::  commits

#: Open the selected file at the selected line

map kitty_mod+p>n khints --type linenum

#::  Select something that looks like filename:linenum and open it in
#::  vim at the specified line number.

#: Open the selected hyperlink

# map kitty_mod+p>y khints --type hyperlink
map kitty_mod+/ khints --alphabet=asdfqwert --hints-foreground-color=#FF1A8F --hints-background-color=#FFE0FF --type url --program -

#::  Select a hyperlink (i.e. a URL that has been marked as such by
#::  the terminal program, for example, by ls --hyperlink=auto).


#: The hints kitten has many more modes of operation that you can map
#: to different shortcuts. For a full description see kittens/hints.
#: }}}

#: Miscellaneous {{{

#: Toggle fullscreen

map kitty_mod+f11 no_op
# map ctrl+cmd+f    kitten zoom_toggle.py
map kitty_mod+enter kitten zoom_toggle.py
# map ctrl+enter kitten zoom_toggle.py

#: Toggle maximized

# map cmd+shift+enter toggle_maximized
map kitty_mod+f10 toggle_maximized
# map cmd+shift+enter kitten zoom_toggle.py

#: Toggle macOS secure keyboard entry

# map opt+cmd+s toggle_macos_secure_keyboard_entry

#: Unicode input

map kitty_mod+u    kitten unicode_input
map cmd+shift+u kitten unicode_input

#: Edit config file

map kitty_mod+f2 edit_config_file
map cmd+,        edit_config_file

#: Open the kitty command shell

map kitty_mod+\ kitty_shell window

#::  Open the kitty shell in a new window/tab/overlay/os_window to
#::  control kitty using commands.

#: Increase background opacity

map kitty_mod+a>m set_background_opacity +0.1

#: Decrease background opacity

map kitty_mod+a>l set_background_opacity -0.1

#: Make background fully opaque

map kitty_mod+a>1 set_background_opacity 1

#: Reset background opacity

map kitty_mod+a>d set_background_opacity default

#: Reset the terminal

# map kitty_mod+delete clear_terminal scroll active
# map opt+cmd+r        clear_terminal scroll active

#::  You can create shortcuts to clear/reset the terminal. For
#::  example::

#::      # Reset the terminal
#::      map kitty_mod+f9 clear_terminal reset active
#::      # Clear the terminal screen by erasing all contents
#::      map kitty_mod+f10 clear_terminal clear active
#::      # Clear the terminal scrollback by erasing it
# map kitty_mod+f11 clear_terminal scrollback active
#::      # Scroll the contents of the screen into the scrollback
# map kitty_mod+f12 clear_terminal scroll active

#::  If you want to operate on all windows instead of just the current
#::  one, use all instead of active.

#::  It is also possible to remap Ctrl+L to both scroll the current
#::  screen contents into the scrollback buffer and clear the screen,
#::  instead of just clearing the screen, for example, for ZSH add the
#::  following to ~/.zshrc:

#::  .. code-block:: sh

#::      scroll-and-clear-screen() {
#::          printf '\n%.0s' {1..$LINES}
#::          zle clear-screen
#::      }
#::      zle -N scroll-and-clear-screen
#::      bindkey '^l' scroll-and-clear-screen

#: Clear up to cursor line

map cmd+k no_op
# map cmd+h no_op

#: Reload kitty.conf

map kitty_mod+f5 load_config_file
map ctrl+cmd+,   load_config_file
# map kitty_mod+space   load_config_file

#::  Reload kitty.conf, applying any changes since the last time it
#::  was loaded. Note that a handful of settings cannot be dynamically
#::  changed and require a full restart of kitty.  You can also map a
#::  keybinding to load a different config file, for example::

#::      map f5 load_config /path/to/alternative/kitty.conf

#::  Note that all setting from the original kitty.conf are discarded,
#::  in other words the new conf settings *replace* the old ones.

#: Debug kitty configuration

map kitty_mod+f6 debug_config
map opt+cmd+,    debug_config

#::  Show details about exactly what configuration kitty is running
#::  with and its host environment. Useful for debugging issues.

#: Send arbitrary text on key presses

#::  E.g. map ctrl+shift+alt+h send_text all Hello World

#::  You can tell kitty to send arbitrary (UTF-8) encoded text to the
#::  client program when pressing specified shortcut keys. For
#::  example::

#::      map ctrl+alt+a send_text all Special text

#::  This will send "Special text" when you press the ctrl+alt+a key
#::  combination.  The text to be sent is a python string literal so
#::  you can use escapes like \x1b to send control codes or \u21fb to
#::  send unicode characters (or you can just input the unicode
#::  characters directly as UTF-8 text). The first argument to
#::  send_text is the keyboard modes in which to activate the
#::  shortcut. The possible values are normal or application or kitty
#::  or a comma separated combination of them.  The special keyword
#::  all means all modes. The modes normal and application refer to #::  the DECCKM cursor key mode for terminals, and kitty refers to the #::  special kitty extended keyboard protocol.
#::  Another example, that outputs a word and then moves the cursor to
#::  the start of the line (same as pressing the Home key)::

#::      map ctrl+alt+a send_text normal Word\x1b[H
#::      map ctrl+alt+a send_text application Word\x1bOH

#: }}}

#: }}}

# moves the window into a new OS window
# map kitty_mod+f2 detach_window
# moves the window into a new tab
# map kitty_mod+f3 detach_window new-tab
# moves the window into the previously active tab
# map kitty_mod+f3 detach_window tab-prev
# moves the window into the tab at the left of the active tab
# map kitty_mod+f3 detach_window tab-left
# asks which tab to move the window into
# map kitty_mod+f4 detach_window ask
# moves the tab into a new OS window
# map ctrl+shift+2 detach_tab
# asks which OS Window to move the tab into
# map ctrl+shift+4 detach_tab ask

# map kitty_mod+f1 remote_control set-tab-color --match='env:USER=samforeman or env:HOSTNAME=^x31' active_fg=#00CCFF inactive_fg=#3399ff

# map ctrl+enter send_text normal,application \x1b[13;5u
# map shift+enter send_text normal,application \x1b[13;2u
# map shift+f1 kitten zoom_toggle.py


map shift+cmd+, kitten kitty_config/config.py
# map kitty_mod+k scroll_to_prompt -1

# Quarto settings
# map ctrl+shift+enter no_op
map shift+enter send_text all \x1b[13;2u
map ctrl+enter send_text all \x1b[13;5u


# map kitty_mod+s      launch --allow-remote-control kitty +kitten kitty_search/search.py @active-kitty-window-id
#
# map kitty_mod+/ launch --location=hsplit --allow-remote-control kitty +kitten search.py @active-kitty-window-id
# map kitty_mod+/      launch --allow-remote-control kitty +kitten kitty_search/search.py @active-kitty-window-id
# map kitty_mod+/      launch --allow-remote-control kitty +kitten kitty_search/search.py @active-kitty-window-id

# map kitty_mod+/ kitten keymap.py
# map ctrl+cmd+/ kitten keymap.py
# map kitty_mod+s     launch  --allow-remote-control kitty +kitten kitty_search/search.py @active-kitty-window-id

# map kitty_mod+; launch --location=hsplit --allow-remote-control kitty +kitten search.py @active-kitty-window-id
# map kitty_mod+; launch --location=hsplit --allow-remote-control kitty +kitten search.py @active-kitty-window-id
#

map kitty_mod+' kitten config.py

# map kitty_mod+/ kitten keymap.py
map cmd+/   launch --allow-remote-control kitty +kitten kitty_search/search.py @active-kitty-window-id
map kitty_mod+s     launch --location=hsplit --allow-remote-control kitty +kitten kitty_search/search.py @active-kitty-window-id
map kitty_mod+;     launch --allow-remote-control kitty +kitten kitty_search/search.py @active-kitty-window-id
map kitty_mod+, launch --allow-remote-control kitty +kitten keymap.py

action_alias myhints kitten hints --alphabet asdfgqwertjkl;uiop1234567789
map kitty_mod+space kitten kitty_grab/grab.py


# Browse scrollback buffer in nvim
map kitty_mod+h kitty_scrollback_nvim
map f9 kitty_scrollback_nvim
# Browse output of the last shell command in nvim
map kitty_mod+g kitty_scrollback_nvim
#--config ksb_builtin_last_cmd_output
map shift+ctrl+. kitten quick-access-terminal
# map shift+ctrl+. kitten quick-access-terminal
# map ctrl+, kitten quick-access-terminal
#
map kitty_mod+f9 kitten quick-access-terminal
map kitty_mod+j kitten quick-access-terminal

# map f1 launch --stdin-source=@screen_scrollback --stdin-add-formatting less +G -R
# map f2 show_kitty_env_vars
